# Как играть
<p>
Играют два игрока в режиме "hotseat". Правила соответствуют 
стандартным русским шашкам, за исключением правила "должен 
бить большинство".
</p>
<p>
Чтобы сделать ход нужно выбрать возможную для хода фигуру (подсвечиваются
светло-голубым), затем выбрать клетку для хода из возможных (также
подсветятся голубым). Правило "тронул - ходи" не активно, поэтому вы можете
"передумать" - для этого еще раз нажмите на фигуру.
</p>
<p>
Справа от доски записываются все ходы, кнопка "Undo" позволяет отменять
последние ходы (от одного до всей партии).
</p>
<p>
Замечание: дамки выделяются другим цветом.
</p>

# Код
<p>
Этот раздел посвящен документации сложных или неявных функций.
</p>

## MainWindow
<p>
Этот код отвечает за визуальную часть: заполнение таблицы, добавление
кнопок, шашек и т.д. 
</p>

### ParseButtonName()
input: string <br>
output: Tuple<char, int>
<p>
Эта функция принимает имя кнопки и возвращает визуальные координаты,
с которыми будет работать класс Game.
</p>

### ButtonClick()
<p>
Обработчик нажатия на кнопку, делает запрос в класс Game и вызывает
отрисовывающую функцию Execute.
</p>

### CreateTable()
<p>
Заполняет grid либо чернымими кнопками, либо белыми "пустышками".
У кнопок есть имена.
</p>

### AddCheckers()
<p>
Отрисовывает шашки в начале игры. У этих шашек есть имена, по которым
их можно будет стирать.
</p>

### Execute()
input: string
<p>
Выполняет определенное действие, связанное с отрисовкой.
</p>

## Game
<p>
Этот класс обеспечивает связь между отрисовкой и логикой доски.
Также он ведет запись ходов и отслеживает состояние игры.
Я пропущу банальные короткие функции, действия которых понятны из
названий и имен аргументов.
</p>

### UndoTurn()
<p>
С помощью логгера, который хранит в себе команды отрисовок всех прошлых
ходов, откатывает действия на доске на 1 ход и возвращает набор 
команд отрисовок, которые нужны, чтобы визуализировать это.
Помимо этого приводит игру в состояние, которое было 1 ход назад.
</p>

### Turn()
<p>
По факту играет каждый ход игры. Принимает имя кнопки, которую нажали
в визуальных координатах. Обрабатывает нажатие в зависимости от стадии
хода (ждем выбор фигуры, ждем выбор хода, когда фигура выбрана, или 
проводим множественную атаку выбранной фигурой). Общая схема такая:
<br/>
1) Проверить кем или куда можно ходить <br/>
2) Соответствует ли наше нажатие возможным ходам <br/>
3) Записать комманды отрисовки, которые будем возвращать в MainWindow <br/>
4) Залоггировать их <br/>
5) Произвести изменения на доске <br/>
6) Перевести ход в другое состояние или окончить его
</p>
<p>
ВАЖНО: пункты 3 и 4 нужно выполнять до пункта 5, иначе можно получить ссылки
на пустые области.
</p>

## Board
<p>
Этот класс контролирует всю логику перемещений и проверок. Содержит в
себе игровую доску, каждая клетка которой содержит либо объект класса
Figure, либо null. У этой доски свои координаты, отличные от визуальных.
</p>
<p>
VisRow2BoardRow, VisCol2BoardCol, BoardRow2VisRow, BoardCol2VisCol - 
конвенторы координат
</p> 
<p>
WhereCheckerCanMove, WhereCheckerCanAttack, WhereQueenCanMove, WhereQueenCanAttack - 
соответствуют своим названиям, по визуальным координатам клетки с фигурой
возвращают список клеток (в визуальных координатах), в которые можно сделать
ход или атаковать.
</p>
<p>
AllPossibleToPick, WhereFigureCanMove, WhereFigureCanAttack - 
функции, обеспечивающие основное взаимодействие с классом Game, 
соответствуют своим названиям, используют в себе функции из прошлого
абзаца.
</p>

### GetKilledFiguresCell
<p>
Эта функция требует максимальной аккуратности в использовании, так как
не содержит в себе важных проверок на не null и предполагает использование
в нужном месте (до изменения состояния на доске).
</p>
<p>
По перемещению фигуры в визуальных координатах 
(начальня клетка + последняя клетка) определяет, где стоит фигура противника,
которую мы съели этим ходом и возвращает ее визуальные координаты.
</p>